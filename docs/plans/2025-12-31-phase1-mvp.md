# Phase 1 MVP Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Build core xmon CLI with X API integration, account management, and basic digest functionality.

**Architecture:** Cobra CLI with SQLite storage, X API v2 client with rate limit tracking, repository pattern for data access.

**Tech Stack:** Go, Cobra, SQLite, X API v2, Lipgloss

---

## Task 1: Project Setup

**Files:**
- Create: `go.mod`
- Create: `main.go`
- Create: `cmd/root.go`
- Create: `.gitignore`
- Create: `README.md`

**Step 1: Initialize Go module**

```bash
cd /Users/julienpequegnot/Code/xmon && go mod init github.com/jpequegn/xmon
```

**Step 2: Create main.go**

```go
// main.go
package main

import "github.com/jpequegn/xmon/cmd"

func main() {
	cmd.Execute()
}
```

**Step 3: Create cmd/root.go**

```go
// cmd/root.go
package cmd

import (
	"fmt"
	"os"

	"github.com/spf13/cobra"
)

var rootCmd = &cobra.Command{
	Use:   "xmon",
	Short: "Monitor X/Twitter accounts and get activity digests",
	Long:  `xmon helps you track influential X accounts, digest their tweets, and surface early signals about emerging topics.`,
}

func Execute() {
	if err := rootCmd.Execute(); err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
}
```

**Step 4: Create .gitignore**

```
# Binaries
xmon
*.exe
*.dll
*.so
*.dylib

# Test binary
*.test

# Output
*.out

# Dependency directories
vendor/

# IDE
.idea/
.vscode/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db

# Config with secrets
config.yaml
*.db
```

**Step 5: Create README.md**

```markdown
# xmon

Monitor X/Twitter accounts and get digests of their activity.

## Features

- Track tweets from accounts you care about
- Detect who influential people are amplifying
- Generate activity digests with trending topics
- Optional LLM-powered analysis of themes
- Export reports to markdown

## Installation

```bash
go install github.com/jpequegn/xmon@latest
```

## Quick Start

```bash
# Initialize with your X API bearer token
xmon init

# Add accounts to monitor
xmon add pmarca
xmon add naval

# Fetch recent tweets
xmon fetch

# View digest
xmon digest

# Get AI-powered insights
xmon digest --smart
```

## Commands

| Command | Description |
|---------|-------------|
| `xmon init` | Initialize config and database |
| `xmon add <user>` | Add an account to monitor |
| `xmon remove <user>` | Remove an account |
| `xmon accounts` | List monitored accounts |
| `xmon fetch` | Pull recent tweets |
| `xmon digest` | Show activity summary |
| `xmon show <user>` | Show user details |
| `xmon export` | Generate markdown report |

## Configuration

Config is stored in `~/.xmon/config.yaml`

```yaml
x:
  bearer_token: "AAAA..."

apis:
  llm_provider: "ollama"
  llm_model: "llama3.2"

digest:
  default_days: 7
```

## Development Status

### Phase 1 (MVP)
- [ ] Project setup
- [ ] init command
- [ ] add/remove commands
- [ ] accounts command
- [ ] X API client
- [ ] fetch command
- [ ] digest command
- [ ] show command

### Phase 2 (Intelligence)
- [ ] LLM integration
- [ ] Most Amplified detection
- [ ] Topic extraction
- [ ] Notable tweets ranking

### Phase 3 (Export & Polish)
- [ ] export command
- [ ] Daemon mode
- [ ] Scraping fallback
```

**Step 6: Install dependencies and build**

```bash
cd /Users/julienpequegnot/Code/xmon && go get github.com/spf13/cobra && go get github.com/charmbracelet/lipgloss && go build -o xmon .
```

**Step 7: Commit**

```bash
cd /Users/julienpequegnot/Code/xmon && git add . && git commit -m "feat: project setup with Cobra CLI"
```

---

## Task 2: Config Package

**Files:**
- Create: `internal/config/config.go`
- Create: `internal/config/config_test.go`

**Step 1: Create config.go**

```go
// internal/config/config.go
package config

import (
	"os"
	"path/filepath"

	"gopkg.in/yaml.v3"
)

type Config struct {
	X      XConfig   `yaml:"x"`
	APIs   APIsConfig `yaml:"apis"`
	Fetch  FetchConfig `yaml:"fetch"`
	Digest DigestConfig `yaml:"digest"`
}

type XConfig struct {
	BearerToken string `yaml:"bearer_token"`
}

type APIsConfig struct {
	LLMProvider string `yaml:"llm_provider"`
	LLMModel    string `yaml:"llm_model"`
}

type FetchConfig struct {
	DefaultInterval int `yaml:"default_interval"`
}

type DigestConfig struct {
	DefaultDays int `yaml:"default_days"`
}

func DefaultConfig() *Config {
	return &Config{
		APIs: APIsConfig{
			LLMProvider: "ollama",
			LLMModel:    "llama3.2",
		},
		Fetch: FetchConfig{
			DefaultInterval: 1440,
		},
		Digest: DigestConfig{
			DefaultDays: 7,
		},
	}
}

func ConfigDir() string {
	home, _ := os.UserHomeDir()
	return filepath.Join(home, ".xmon")
}

func ConfigPath() string {
	return filepath.Join(ConfigDir(), "config.yaml")
}

func DBPath() string {
	return filepath.Join(ConfigDir(), "xmon.db")
}

func Load() (*Config, error) {
	data, err := os.ReadFile(ConfigPath())
	if err != nil {
		return nil, err
	}

	cfg := DefaultConfig()
	if err := yaml.Unmarshal(data, cfg); err != nil {
		return nil, err
	}

	return cfg, nil
}

func (c *Config) Save() error {
	if err := os.MkdirAll(ConfigDir(), 0755); err != nil {
		return err
	}

	data, err := yaml.Marshal(c)
	if err != nil {
		return err
	}

	return os.WriteFile(ConfigPath(), data, 0600)
}
```

**Step 2: Create config_test.go**

```go
// internal/config/config_test.go
package config

import (
	"testing"
)

func TestDefaultConfig(t *testing.T) {
	cfg := DefaultConfig()
	if cfg.Digest.DefaultDays != 7 {
		t.Errorf("expected default days 7, got %d", cfg.Digest.DefaultDays)
	}
	if cfg.APIs.LLMModel != "llama3.2" {
		t.Errorf("expected llama3.2, got %s", cfg.APIs.LLMModel)
	}
}

func TestConfigDir(t *testing.T) {
	dir := ConfigDir()
	if dir == "" {
		t.Error("config dir should not be empty")
	}
}
```

**Step 3: Install yaml dependency and run tests**

```bash
cd /Users/julienpequegnot/Code/xmon && go get gopkg.in/yaml.v3 && go test ./internal/config/... -v
```

**Step 4: Commit**

```bash
cd /Users/julienpequegnot/Code/xmon && git add . && git commit -m "feat: add config package"
```

---

## Task 3: Database Package

**Files:**
- Create: `internal/database/database.go`
- Create: `internal/database/database_test.go`

**Step 1: Create database.go**

```go
// internal/database/database.go
package database

import (
	"database/sql"

	_ "github.com/mattn/go-sqlite3"
)

type DB struct {
	*sql.DB
}

func New(path string) (*DB, error) {
	db, err := sql.Open("sqlite3", path)
	if err != nil {
		return nil, err
	}

	if err := db.Ping(); err != nil {
		return nil, err
	}

	wrapper := &DB{db}
	if err := wrapper.initSchema(); err != nil {
		return nil, err
	}

	return wrapper, nil
}

func (db *DB) initSchema() error {
	schema := `
	CREATE TABLE IF NOT EXISTS accounts (
		id INTEGER PRIMARY KEY,
		user_id TEXT UNIQUE NOT NULL,
		username TEXT NOT NULL,
		name TEXT,
		bio TEXT,
		followers INTEGER,
		added_at DATETIME DEFAULT CURRENT_TIMESTAMP,
		last_fetched DATETIME
	);

	CREATE TABLE IF NOT EXISTS tweets (
		id INTEGER PRIMARY KEY,
		account_id INTEGER NOT NULL,
		tweet_id TEXT UNIQUE NOT NULL,
		tweet_type TEXT NOT NULL,
		content TEXT,
		referenced_user TEXT,
		referenced_tweet_id TEXT,
		likes INTEGER DEFAULT 0,
		retweets INTEGER DEFAULT 0,
		created_at DATETIME,
		fetched_at DATETIME DEFAULT CURRENT_TIMESTAMP,
		FOREIGN KEY (account_id) REFERENCES accounts(id)
	);

	CREATE TABLE IF NOT EXISTS api_usage (
		id INTEGER PRIMARY KEY,
		month TEXT UNIQUE NOT NULL,
		tweets_read INTEGER DEFAULT 0,
		updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
	);

	CREATE INDEX IF NOT EXISTS idx_tweets_account ON tweets(account_id);
	CREATE INDEX IF NOT EXISTS idx_tweets_created ON tweets(created_at);
	CREATE INDEX IF NOT EXISTS idx_tweets_type ON tweets(tweet_type);
	`

	_, err := db.Exec(schema)
	return err
}
```

**Step 2: Create database_test.go**

```go
// internal/database/database_test.go
package database

import (
	"os"
	"testing"
)

func TestNewDB(t *testing.T) {
	tmpfile, err := os.CreateTemp("", "xmon-test-*.db")
	if err != nil {
		t.Fatal(err)
	}
	defer os.Remove(tmpfile.Name())

	db, err := New(tmpfile.Name())
	if err != nil {
		t.Fatalf("failed to create db: %v", err)
	}
	defer db.Close()

	if db == nil {
		t.Error("expected non-nil db")
	}
}
```

**Step 3: Install sqlite dependency and run tests**

```bash
cd /Users/julienpequegnot/Code/xmon && go get github.com/mattn/go-sqlite3 && go test ./internal/database/... -v
```

**Step 4: Commit**

```bash
cd /Users/julienpequegnot/Code/xmon && git add . && git commit -m "feat: add database package with schema"
```

---

## Task 4: Account Repository

**Files:**
- Create: `internal/account/repository.go`
- Create: `internal/account/repository_test.go`

**Step 1: Create repository.go**

```go
// internal/account/repository.go
package account

import (
	"time"

	"github.com/jpequegn/xmon/internal/database"
)

type Account struct {
	ID          int64
	UserID      string
	Username    string
	Name        string
	Bio         string
	Followers   int
	AddedAt     time.Time
	LastFetched *time.Time
}

type Repository struct {
	db *database.DB
}

func NewRepository(db *database.DB) *Repository {
	return &Repository{db: db}
}

func (r *Repository) Add(userID, username, name, bio string, followers int) error {
	_, err := r.db.Exec(
		`INSERT OR REPLACE INTO accounts (user_id, username, name, bio, followers) VALUES (?, ?, ?, ?, ?)`,
		userID, username, name, bio, followers,
	)
	return err
}

func (r *Repository) Remove(username string) error {
	_, err := r.db.Exec(`DELETE FROM accounts WHERE username = ?`, username)
	return err
}

func (r *Repository) List() ([]Account, error) {
	rows, err := r.db.Query(`SELECT id, user_id, username, name, bio, followers, added_at, last_fetched FROM accounts ORDER BY username`)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var accounts []Account
	for rows.Next() {
		var a Account
		if err := rows.Scan(&a.ID, &a.UserID, &a.Username, &a.Name, &a.Bio, &a.Followers, &a.AddedAt, &a.LastFetched); err != nil {
			return nil, err
		}
		accounts = append(accounts, a)
	}
	return accounts, rows.Err()
}

func (r *Repository) Get(username string) (*Account, error) {
	var a Account
	err := r.db.QueryRow(
		`SELECT id, user_id, username, name, bio, followers, added_at, last_fetched FROM accounts WHERE username = ?`,
		username,
	).Scan(&a.ID, &a.UserID, &a.Username, &a.Name, &a.Bio, &a.Followers, &a.AddedAt, &a.LastFetched)
	if err != nil {
		return nil, err
	}
	return &a, nil
}

func (r *Repository) GetByID(id int64) (*Account, error) {
	var a Account
	err := r.db.QueryRow(
		`SELECT id, user_id, username, name, bio, followers, added_at, last_fetched FROM accounts WHERE id = ?`,
		id,
	).Scan(&a.ID, &a.UserID, &a.Username, &a.Name, &a.Bio, &a.Followers, &a.AddedAt, &a.LastFetched)
	if err != nil {
		return nil, err
	}
	return &a, nil
}

func (r *Repository) Exists(username string) bool {
	var count int
	r.db.QueryRow(`SELECT COUNT(*) FROM accounts WHERE username = ?`, username).Scan(&count)
	return count > 0
}

func (r *Repository) UpdateLastFetched(id int64) error {
	_, err := r.db.Exec(`UPDATE accounts SET last_fetched = CURRENT_TIMESTAMP WHERE id = ?`, id)
	return err
}
```

**Step 2: Create repository_test.go**

```go
// internal/account/repository_test.go
package account

import (
	"os"
	"testing"

	"github.com/jpequegn/xmon/internal/database"
)

func setupTestDB(t *testing.T) (*database.DB, func()) {
	tmpfile, err := os.CreateTemp("", "xmon-test-*.db")
	if err != nil {
		t.Fatal(err)
	}

	db, err := database.New(tmpfile.Name())
	if err != nil {
		os.Remove(tmpfile.Name())
		t.Fatal(err)
	}

	return db, func() {
		db.Close()
		os.Remove(tmpfile.Name())
	}
}

func TestAddAccount(t *testing.T) {
	db, cleanup := setupTestDB(t)
	defer cleanup()

	repo := NewRepository(db)
	err := repo.Add("123456", "testuser", "Test User", "A test bio", 1000)
	if err != nil {
		t.Fatalf("failed to add account: %v", err)
	}

	if !repo.Exists("testuser") {
		t.Error("account should exist after adding")
	}
}

func TestListAccounts(t *testing.T) {
	db, cleanup := setupTestDB(t)
	defer cleanup()

	repo := NewRepository(db)
	repo.Add("123", "alice", "Alice", "", 100)
	repo.Add("456", "bob", "Bob", "", 200)

	accounts, err := repo.List()
	if err != nil {
		t.Fatalf("failed to list: %v", err)
	}

	if len(accounts) != 2 {
		t.Errorf("expected 2 accounts, got %d", len(accounts))
	}
}

func TestRemoveAccount(t *testing.T) {
	db, cleanup := setupTestDB(t)
	defer cleanup()

	repo := NewRepository(db)
	repo.Add("123", "testuser", "Test", "", 100)
	repo.Remove("testuser")

	if repo.Exists("testuser") {
		t.Error("account should not exist after removal")
	}
}
```

**Step 3: Run tests**

```bash
cd /Users/julienpequegnot/Code/xmon && go test ./internal/account/... -v
```

**Step 4: Commit**

```bash
cd /Users/julienpequegnot/Code/xmon && git add . && git commit -m "feat: add account repository"
```

---

## Task 5: Init Command

**Files:**
- Create: `cmd/init.go`

**Step 1: Create init.go**

```go
// cmd/init.go
package cmd

import (
	"bufio"
	"fmt"
	"os"
	"strings"

	"github.com/jpequegn/xmon/internal/config"
	"github.com/jpequegn/xmon/internal/database"
	"github.com/spf13/cobra"
)

var initCmd = &cobra.Command{
	Use:   "init",
	Short: "Initialize xmon configuration",
	Long:  `Creates the config directory, database, and prompts for your X API bearer token.`,
	RunE:  runInit,
}

func init() {
	rootCmd.AddCommand(initCmd)
}

func runInit(cmd *cobra.Command, args []string) error {
	fmt.Println("Initializing xmon...")

	// Create config directory
	if err := os.MkdirAll(config.ConfigDir(), 0755); err != nil {
		return fmt.Errorf("failed to create config directory: %w", err)
	}
	fmt.Printf("Created config directory: %s\n", config.ConfigDir())

	// Initialize database
	db, err := database.New(config.DBPath())
	if err != nil {
		return fmt.Errorf("failed to create database: %w", err)
	}
	db.Close()
	fmt.Printf("Created database: %s\n", config.DBPath())

	// Load or create config
	cfg, err := config.Load()
	if err != nil {
		cfg = config.DefaultConfig()
	}

	// Prompt for bearer token if not set
	if cfg.X.BearerToken == "" {
		fmt.Print("\nEnter your X API Bearer Token: ")
		reader := bufio.NewReader(os.Stdin)
		token, _ := reader.ReadString('\n')
		token = strings.TrimSpace(token)

		if token != "" {
			cfg.X.BearerToken = token
		}
	}

	// Save config
	if err := cfg.Save(); err != nil {
		return fmt.Errorf("failed to save config: %w", err)
	}
	fmt.Printf("Saved config: %s\n", config.ConfigPath())

	fmt.Println("\nxmon initialized successfully!")
	fmt.Println("Next: Run 'xmon add <username>' to add accounts to monitor.")

	return nil
}
```

**Step 2: Build and test**

```bash
cd /Users/julienpequegnot/Code/xmon && go build -o xmon . && ./xmon init --help
```

**Step 3: Commit**

```bash
cd /Users/julienpequegnot/Code/xmon && git add . && git commit -m "feat: add init command"
```

---

## Task 6: X API Client

**Files:**
- Create: `internal/x/client.go`
- Create: `internal/x/client_test.go`

**Step 1: Create client.go**

```go
// internal/x/client.go
package x

import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"strconv"
	"time"
)

const baseURL = "https://api.twitter.com/2"

type Client struct {
	bearerToken        string
	httpClient         *http.Client
	rateLimitRemaining int
	rateLimitReset     time.Time
}

type User struct {
	ID          string `json:"id"`
	Username    string `json:"username"`
	Name        string `json:"name"`
	Description string `json:"description"`
	PublicMetrics struct {
		FollowersCount int `json:"followers_count"`
		FollowingCount int `json:"following_count"`
		TweetCount     int `json:"tweet_count"`
	} `json:"public_metrics"`
}

type Tweet struct {
	ID                string    `json:"id"`
	Text              string    `json:"text"`
	CreatedAt         time.Time `json:"created_at"`
	PublicMetrics     struct {
		RetweetCount int `json:"retweet_count"`
		LikeCount    int `json:"like_count"`
	} `json:"public_metrics"`
	ReferencedTweets []struct {
		Type string `json:"type"`
		ID   string `json:"id"`
	} `json:"referenced_tweets"`
}

type UserResponse struct {
	Data User `json:"data"`
}

type TweetsResponse struct {
	Data []Tweet `json:"data"`
	Meta struct {
		NewestID    string `json:"newest_id"`
		OldestID    string `json:"oldest_id"`
		ResultCount int    `json:"result_count"`
		NextToken   string `json:"next_token"`
	} `json:"meta"`
	Includes struct {
		Users []User `json:"users"`
	} `json:"includes"`
}

func NewClient(bearerToken string) *Client {
	return &Client{
		bearerToken: bearerToken,
		httpClient: &http.Client{
			Timeout: 30 * time.Second,
		},
	}
}

func (c *Client) doRequest(url string) ([]byte, error) {
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Authorization", "Bearer "+c.bearerToken)

	resp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	// Parse rate limit headers
	if remaining := resp.Header.Get("x-rate-limit-remaining"); remaining != "" {
		if val, err := strconv.Atoi(remaining); err == nil {
			c.rateLimitRemaining = val
		}
	}
	if reset := resp.Header.Get("x-rate-limit-reset"); reset != "" {
		if val, err := strconv.ParseInt(reset, 10, 64); err == nil {
			c.rateLimitReset = time.Unix(val, 0)
		}
	}

	if resp.StatusCode != http.StatusOK {
		body, _ := io.ReadAll(resp.Body)
		return nil, fmt.Errorf("X API error %d: %s", resp.StatusCode, string(body))
	}

	return io.ReadAll(resp.Body)
}

func (c *Client) GetUser(username string) (*User, error) {
	url := fmt.Sprintf("%s/users/by/username/%s?user.fields=description,public_metrics", baseURL, username)
	data, err := c.doRequest(url)
	if err != nil {
		return nil, err
	}

	var resp UserResponse
	if err := json.Unmarshal(data, &resp); err != nil {
		return nil, err
	}

	return &resp.Data, nil
}

func (c *Client) GetUserTweets(userID string, sinceID string) (*TweetsResponse, error) {
	url := fmt.Sprintf("%s/users/%s/tweets?max_results=100&tweet.fields=created_at,public_metrics,referenced_tweets&expansions=referenced_tweets.id.author_id&user.fields=username",
		baseURL, userID)

	if sinceID != "" {
		url += "&since_id=" + sinceID
	}

	data, err := c.doRequest(url)
	if err != nil {
		return nil, err
	}

	var resp TweetsResponse
	if err := json.Unmarshal(data, &resp); err != nil {
		return nil, err
	}

	return &resp, nil
}

func (c *Client) RateLimitRemaining() int {
	return c.rateLimitRemaining
}

func (c *Client) RateLimitReset() time.Time {
	return c.rateLimitReset
}

func (c *Client) WaitForRateLimit() {
	if c.rateLimitRemaining > 0 && c.rateLimitRemaining < 5 && time.Now().Before(c.rateLimitReset) {
		waitTime := time.Until(c.rateLimitReset) + time.Second
		fmt.Printf("Rate limit low (%d remaining), waiting %v...\n", c.rateLimitRemaining, waitTime.Round(time.Second))
		time.Sleep(waitTime)
	}
}

// GetTweetType determines if a tweet is original, retweet, or quote
func GetTweetType(tweet Tweet) string {
	for _, ref := range tweet.ReferencedTweets {
		if ref.Type == "retweeted" {
			return "retweet"
		}
		if ref.Type == "quoted" {
			return "quote"
		}
	}
	return "original"
}
```

**Step 2: Create client_test.go**

```go
// internal/x/client_test.go
package x

import (
	"testing"
)

func TestNewClient(t *testing.T) {
	client := NewClient("test-token")
	if client == nil {
		t.Error("expected non-nil client")
	}
}

func TestGetTweetType(t *testing.T) {
	tests := []struct {
		name     string
		tweet    Tweet
		expected string
	}{
		{
			name:     "original tweet",
			tweet:    Tweet{},
			expected: "original",
		},
		{
			name: "retweet",
			tweet: Tweet{
				ReferencedTweets: []struct {
					Type string `json:"type"`
					ID   string `json:"id"`
				}{{Type: "retweeted", ID: "123"}},
			},
			expected: "retweet",
		},
		{
			name: "quote tweet",
			tweet: Tweet{
				ReferencedTweets: []struct {
					Type string `json:"type"`
					ID   string `json:"id"`
				}{{Type: "quoted", ID: "456"}},
			},
			expected: "quote",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := GetTweetType(tt.tweet)
			if result != tt.expected {
				t.Errorf("expected %s, got %s", tt.expected, result)
			}
		})
	}
}
```

**Step 3: Run tests**

```bash
cd /Users/julienpequegnot/Code/xmon && go test ./internal/x/... -v
```

**Step 4: Commit**

```bash
cd /Users/julienpequegnot/Code/xmon && git add . && git commit -m "feat: add X API client"
```

---

## Task 7: Add/Remove Commands

**Files:**
- Create: `cmd/add.go`
- Create: `cmd/remove.go`

**Step 1: Create add.go**

```go
// cmd/add.go
package cmd

import (
	"fmt"

	"github.com/jpequegn/xmon/internal/account"
	"github.com/jpequegn/xmon/internal/config"
	"github.com/jpequegn/xmon/internal/database"
	"github.com/jpequegn/xmon/internal/x"
	"github.com/spf13/cobra"
)

var addCmd = &cobra.Command{
	Use:   "add <username>",
	Short: "Add an X account to monitor",
	Long:  `Adds an X account to your monitoring list by username (without @).`,
	Args:  cobra.ExactArgs(1),
	RunE:  runAdd,
}

func init() {
	rootCmd.AddCommand(addCmd)
}

func runAdd(cmd *cobra.Command, args []string) error {
	username := args[0]

	cfg, err := config.Load()
	if err != nil {
		return fmt.Errorf("failed to load config: %w (run 'xmon init' first)", err)
	}

	if cfg.X.BearerToken == "" {
		return fmt.Errorf("X API bearer token not set. Add it to %s", config.ConfigPath())
	}

	db, err := database.New(config.DBPath())
	if err != nil {
		return fmt.Errorf("failed to open database: %w", err)
	}
	defer db.Close()

	repo := account.NewRepository(db)
	if repo.Exists(username) {
		return fmt.Errorf("account @%s is already being monitored", username)
	}

	// Fetch user info from X API
	client := x.NewClient(cfg.X.BearerToken)
	user, err := client.GetUser(username)
	if err != nil {
		return fmt.Errorf("failed to fetch user @%s: %w", username, err)
	}

	// Add to database
	if err := repo.Add(user.ID, user.Username, user.Name, user.Description, user.PublicMetrics.FollowersCount); err != nil {
		return fmt.Errorf("failed to add account: %w", err)
	}

	fmt.Printf("Added @%s (%s) - %d followers\n", user.Username, user.Name, user.PublicMetrics.FollowersCount)
	return nil
}
```

**Step 2: Create remove.go**

```go
// cmd/remove.go
package cmd

import (
	"fmt"

	"github.com/jpequegn/xmon/internal/account"
	"github.com/jpequegn/xmon/internal/config"
	"github.com/jpequegn/xmon/internal/database"
	"github.com/spf13/cobra"
)

var removeCmd = &cobra.Command{
	Use:   "remove <username>",
	Short: "Remove an X account from monitoring",
	Long:  `Removes an X account from your monitoring list.`,
	Args:  cobra.ExactArgs(1),
	RunE:  runRemove,
}

func init() {
	rootCmd.AddCommand(removeCmd)
}

func runRemove(cmd *cobra.Command, args []string) error {
	username := args[0]

	db, err := database.New(config.DBPath())
	if err != nil {
		return fmt.Errorf("failed to open database: %w", err)
	}
	defer db.Close()

	repo := account.NewRepository(db)
	if !repo.Exists(username) {
		return fmt.Errorf("account @%s is not being monitored", username)
	}

	if err := repo.Remove(username); err != nil {
		return fmt.Errorf("failed to remove account: %w", err)
	}

	fmt.Printf("Removed @%s from monitoring\n", username)
	return nil
}
```

**Step 3: Build and test**

```bash
cd /Users/julienpequegnot/Code/xmon && go build -o xmon . && ./xmon add --help && ./xmon remove --help
```

**Step 4: Commit**

```bash
cd /Users/julienpequegnot/Code/xmon && git add . && git commit -m "feat: add add/remove commands"
```

---

## Task 8: Accounts Command

**Files:**
- Create: `cmd/accounts.go`

**Step 1: Create accounts.go**

```go
// cmd/accounts.go
package cmd

import (
	"fmt"

	"github.com/charmbracelet/lipgloss"
	"github.com/jpequegn/xmon/internal/account"
	"github.com/jpequegn/xmon/internal/config"
	"github.com/jpequegn/xmon/internal/database"
	"github.com/spf13/cobra"
)

var accountsCmd = &cobra.Command{
	Use:   "accounts",
	Short: "List monitored accounts",
	Long:  `Shows all X accounts you are currently monitoring.`,
	RunE:  runAccounts,
}

func init() {
	rootCmd.AddCommand(accountsCmd)
}

func runAccounts(cmd *cobra.Command, args []string) error {
	db, err := database.New(config.DBPath())
	if err != nil {
		return fmt.Errorf("failed to open database: %w", err)
	}
	defer db.Close()

	repo := account.NewRepository(db)
	accounts, err := repo.List()
	if err != nil {
		return fmt.Errorf("failed to list accounts: %w", err)
	}

	if len(accounts) == 0 {
		fmt.Println("No accounts being monitored.")
		fmt.Println("Run 'xmon add <username>' to add accounts.")
		return nil
	}

	titleStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color("39"))
	userStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("205"))
	dimStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("240"))

	fmt.Printf("\n%s\n\n", titleStyle.Render("Monitored Accounts"))

	for _, acc := range accounts {
		fmt.Printf("  %s", userStyle.Render("@"+acc.Username))
		if acc.Name != "" {
			fmt.Printf(" (%s)", acc.Name)
		}
		fmt.Println()
		fmt.Printf("    %s\n", dimStyle.Render(fmt.Sprintf("%d followers", acc.Followers)))
	}

	fmt.Printf("\n%s\n", dimStyle.Render(fmt.Sprintf("Total: %d accounts", len(accounts))))

	return nil
}
```

**Step 2: Build and test**

```bash
cd /Users/julienpequegnot/Code/xmon && go build -o xmon . && ./xmon accounts --help
```

**Step 3: Commit**

```bash
cd /Users/julienpequegnot/Code/xmon && git add . && git commit -m "feat: add accounts command"
```

---

## Task 9: Tweet Repository

**Files:**
- Create: `internal/tweet/repository.go`

**Step 1: Create repository.go**

```go
// internal/tweet/repository.go
package tweet

import (
	"time"

	"github.com/jpequegn/xmon/internal/database"
)

type Tweet struct {
	ID               int64
	AccountID        int64
	TweetID          string
	TweetType        string
	Content          string
	ReferencedUser   string
	ReferencedTweetID string
	Likes            int
	Retweets         int
	CreatedAt        time.Time
}

type Repository struct {
	db *database.DB
}

func NewRepository(db *database.DB) *Repository {
	return &Repository{db: db}
}

func (r *Repository) Add(accountID int64, tweetID, tweetType, content, refUser, refTweetID string, likes, retweets int, createdAt time.Time) error {
	_, err := r.db.Exec(
		`INSERT OR IGNORE INTO tweets (account_id, tweet_id, tweet_type, content, referenced_user, referenced_tweet_id, likes, retweets, created_at) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`,
		accountID, tweetID, tweetType, content, refUser, refTweetID, likes, retweets, createdAt,
	)
	return err
}

func (r *Repository) GetSince(since time.Time) ([]Tweet, error) {
	rows, err := r.db.Query(`
		SELECT id, account_id, tweet_id, tweet_type, content, referenced_user, referenced_tweet_id, likes, retweets, created_at
		FROM tweets
		WHERE created_at >= ?
		ORDER BY created_at DESC
	`, since)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var tweets []Tweet
	for rows.Next() {
		var t Tweet
		if err := rows.Scan(&t.ID, &t.AccountID, &t.TweetID, &t.TweetType, &t.Content, &t.ReferencedUser, &t.ReferencedTweetID, &t.Likes, &t.Retweets, &t.CreatedAt); err != nil {
			return nil, err
		}
		tweets = append(tweets, t)
	}
	return tweets, rows.Err()
}

func (r *Repository) GetForAccount(accountID int64, since time.Time) ([]Tweet, error) {
	rows, err := r.db.Query(`
		SELECT id, account_id, tweet_id, tweet_type, content, referenced_user, referenced_tweet_id, likes, retweets, created_at
		FROM tweets
		WHERE account_id = ? AND created_at >= ?
		ORDER BY created_at DESC
	`, accountID, since)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var tweets []Tweet
	for rows.Next() {
		var t Tweet
		if err := rows.Scan(&t.ID, &t.AccountID, &t.TweetID, &t.TweetType, &t.Content, &t.ReferencedUser, &t.ReferencedTweetID, &t.Likes, &t.Retweets, &t.CreatedAt); err != nil {
			return nil, err
		}
		tweets = append(tweets, t)
	}
	return tweets, rows.Err()
}

func (r *Repository) CountByType(since time.Time) (originals, retweets, quotes int, err error) {
	row := r.db.QueryRow(`
		SELECT
			SUM(CASE WHEN tweet_type = 'original' THEN 1 ELSE 0 END),
			SUM(CASE WHEN tweet_type = 'retweet' THEN 1 ELSE 0 END),
			SUM(CASE WHEN tweet_type = 'quote' THEN 1 ELSE 0 END)
		FROM tweets WHERE created_at >= ?
	`, since)
	err = row.Scan(&originals, &retweets, &quotes)
	return
}

func (r *Repository) GetMostAmplified(since time.Time, limit int) ([]struct {
	Username string
	Count    int
}, error) {
	rows, err := r.db.Query(`
		SELECT referenced_user, COUNT(*) as count
		FROM tweets
		WHERE created_at >= ? AND tweet_type IN ('retweet', 'quote') AND referenced_user != ''
		GROUP BY referenced_user
		ORDER BY count DESC
		LIMIT ?
	`, since, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []struct {
		Username string
		Count    int
	}
	for rows.Next() {
		var r struct {
			Username string
			Count    int
		}
		if err := rows.Scan(&r.Username, &r.Count); err != nil {
			return nil, err
		}
		results = append(results, r)
	}
	return results, rows.Err()
}

func (r *Repository) GetTopTweets(since time.Time, limit int) ([]Tweet, error) {
	rows, err := r.db.Query(`
		SELECT id, account_id, tweet_id, tweet_type, content, referenced_user, referenced_tweet_id, likes, retweets, created_at
		FROM tweets
		WHERE created_at >= ? AND tweet_type = 'original'
		ORDER BY (likes + retweets) DESC
		LIMIT ?
	`, since, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var tweets []Tweet
	for rows.Next() {
		var t Tweet
		if err := rows.Scan(&t.ID, &t.AccountID, &t.TweetID, &t.TweetType, &t.Content, &t.ReferencedUser, &t.ReferencedTweetID, &t.Likes, &t.Retweets, &t.CreatedAt); err != nil {
			return nil, err
		}
		tweets = append(tweets, t)
	}
	return tweets, rows.Err()
}
```

**Step 2: Build**

```bash
cd /Users/julienpequegnot/Code/xmon && go build -o xmon .
```

**Step 3: Commit**

```bash
cd /Users/julienpequegnot/Code/xmon && git add . && git commit -m "feat: add tweet repository"
```

---

## Task 10: Fetch Command

**Files:**
- Create: `cmd/fetch.go`

**Step 1: Create fetch.go**

```go
// cmd/fetch.go
package cmd

import (
	"fmt"

	"github.com/jpequegn/xmon/internal/account"
	"github.com/jpequegn/xmon/internal/config"
	"github.com/jpequegn/xmon/internal/database"
	"github.com/jpequegn/xmon/internal/tweet"
	"github.com/jpequegn/xmon/internal/x"
	"github.com/spf13/cobra"
)

var fetchCmd = &cobra.Command{
	Use:   "fetch",
	Short: "Fetch tweets from monitored accounts",
	Long:  `Downloads recent tweets from all monitored X accounts.`,
	RunE:  runFetch,
}

func init() {
	rootCmd.AddCommand(fetchCmd)
}

func runFetch(cmd *cobra.Command, args []string) error {
	cfg, err := config.Load()
	if err != nil {
		return fmt.Errorf("failed to load config: %w", err)
	}

	if cfg.X.BearerToken == "" {
		return fmt.Errorf("X API bearer token not set. Add it to %s", config.ConfigPath())
	}

	db, err := database.New(config.DBPath())
	if err != nil {
		return fmt.Errorf("failed to open database: %w", err)
	}
	defer db.Close()

	accountRepo := account.NewRepository(db)
	tweetRepo := tweet.NewRepository(db)

	accounts, err := accountRepo.List()
	if err != nil {
		return fmt.Errorf("failed to list accounts: %w", err)
	}

	if len(accounts) == 0 {
		fmt.Println("No accounts to fetch. Run 'xmon add <username>' first.")
		return nil
	}

	client := x.NewClient(cfg.X.BearerToken)

	fmt.Printf("Fetching tweets for %d accounts...\n\n", len(accounts))

	totalTweets := 0

	for _, acc := range accounts {
		client.WaitForRateLimit()

		tweetsResp, err := client.GetUserTweets(acc.UserID, "")
		if err != nil {
			fmt.Printf("  @%s: error - %v\n", acc.Username, err)
			continue
		}

		count := 0
		for _, tw := range tweetsResp.Data {
			tweetType := x.GetTweetType(tw)

			// Get referenced user for RTs/quotes
			refUser := ""
			refTweetID := ""
			if len(tw.ReferencedTweets) > 0 {
				refTweetID = tw.ReferencedTweets[0].ID
				// Try to find the author in includes
				for _, u := range tweetsResp.Includes.Users {
					refUser = u.Username
					break
				}
			}

			err := tweetRepo.Add(
				acc.ID,
				tw.ID,
				tweetType,
				tw.Text,
				refUser,
				refTweetID,
				tw.PublicMetrics.LikeCount,
				tw.PublicMetrics.RetweetCount,
				tw.CreatedAt,
			)
			if err == nil {
				count++
			}
		}

		accountRepo.UpdateLastFetched(acc.ID)
		fmt.Printf("  @%s: %d tweets\n", acc.Username, count)
		totalTweets += count
	}

	fmt.Printf("\nFetch complete: %d new tweets\n", totalTweets)

	if client.RateLimitRemaining() > 0 {
		fmt.Printf("Rate limit: %d requests remaining (resets %s)\n",
			client.RateLimitRemaining(),
			client.RateLimitReset().Format("15:04"))
	}

	fmt.Println("Run 'xmon digest' to see the summary.")

	return nil
}
```

**Step 2: Build and test**

```bash
cd /Users/julienpequegnot/Code/xmon && go build -o xmon . && ./xmon fetch --help
```

**Step 3: Commit**

```bash
cd /Users/julienpequegnot/Code/xmon && git add . && git commit -m "feat: add fetch command"
```

---

## Task 11: Digest Command

**Files:**
- Create: `cmd/digest.go`

**Step 1: Create digest.go**

```go
// cmd/digest.go
package cmd

import (
	"fmt"
	"time"

	"github.com/charmbracelet/lipgloss"
	"github.com/jpequegn/xmon/internal/account"
	"github.com/jpequegn/xmon/internal/config"
	"github.com/jpequegn/xmon/internal/database"
	"github.com/jpequegn/xmon/internal/tweet"
	"github.com/spf13/cobra"
)

var digestCmd = &cobra.Command{
	Use:   "digest",
	Short: "Show activity digest",
	Long:  `Displays a summary of recent tweets from monitored accounts.`,
	RunE:  runDigest,
}

var (
	digestDays int
)

func init() {
	rootCmd.AddCommand(digestCmd)
	digestCmd.Flags().IntVar(&digestDays, "days", 7, "Number of days to include in digest")
}

func runDigest(cmd *cobra.Command, args []string) error {
	db, err := database.New(config.DBPath())
	if err != nil {
		return fmt.Errorf("failed to open database: %w", err)
	}
	defer db.Close()

	since := time.Now().AddDate(0, 0, -digestDays)
	endDate := time.Now()

	accountRepo := account.NewRepository(db)
	tweetRepo := tweet.NewRepository(db)

	accounts, _ := accountRepo.List()
	accountMap := make(map[int64]*account.Account)
	for i := range accounts {
		accountMap[accounts[i].ID] = &accounts[i]
	}

	originals, retweets, quotes, _ := tweetRepo.CountByType(since)
	totalTweets := originals + retweets + quotes

	titleStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color("205"))
	sectionStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color("39"))
	userStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("39"))
	dimStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("240"))

	fmt.Printf("\n%s (%s - %s)\n",
		titleStyle.Render("X DIGEST"),
		since.Format("Jan 2"),
		endDate.Format("Jan 2, 2006"))
	fmt.Println(lipgloss.NewStyle().Foreground(lipgloss.Color("240")).Render("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"))

	fmt.Printf("\nðŸ“Š Summary: %d accounts Â· %d tweets Â· %d retweets Â· %d quotes\n\n",
		len(accounts), originals, retweets, quotes)

	// Most Active
	if totalTweets > 0 {
		fmt.Printf("%s\n", sectionStyle.Render("ðŸ”¥ Most Active"))
		tweets, _ := tweetRepo.GetSince(since)

		tweetCounts := make(map[int64]int)
		for _, t := range tweets {
			tweetCounts[t.AccountID]++
		}

		type accountTweets struct {
			username string
			count    int
		}
		var sorted []accountTweets
		for accID, count := range tweetCounts {
			if acc, ok := accountMap[accID]; ok {
				sorted = append(sorted, accountTweets{acc.Username, count})
			}
		}

		// Simple sort
		for i := 0; i < len(sorted); i++ {
			for j := i + 1; j < len(sorted); j++ {
				if sorted[j].count > sorted[i].count {
					sorted[i], sorted[j] = sorted[j], sorted[i]
				}
			}
		}

		limit := 5
		if len(sorted) < limit {
			limit = len(sorted)
		}
		for i := 0; i < limit; i++ {
			fmt.Printf("  %-20s %d tweets\n",
				userStyle.Render("@"+sorted[i].username),
				sorted[i].count)
		}
		fmt.Println()
	}

	// Most Amplified
	amplified, _ := tweetRepo.GetMostAmplified(since, 5)
	if len(amplified) > 0 {
		fmt.Printf("%s\n", sectionStyle.Render("ðŸ” Most Amplified"))
		for _, a := range amplified {
			fmt.Printf("  %-20s %s\n",
				userStyle.Render("@"+a.Username),
				dimStyle.Render(fmt.Sprintf("(%d times)", a.Count)))
		}
		fmt.Println()
	}

	// Notable Tweets
	topTweets, _ := tweetRepo.GetTopTweets(since, 3)
	if len(topTweets) > 0 {
		fmt.Printf("%s\n", sectionStyle.Render("ðŸ’¬ Notable Tweets"))
		for _, t := range topTweets {
			if acc, ok := accountMap[t.AccountID]; ok {
				content := t.Content
				if len(content) > 80 {
					content = content[:77] + "..."
				}
				fmt.Printf("  %s: %s\n", userStyle.Render("@"+acc.Username), content)
				fmt.Printf("    %s\n", dimStyle.Render(fmt.Sprintf("â†³ %d likes Â· %d RTs", t.Likes, t.Retweets)))
			}
		}
		fmt.Println()
	}

	return nil
}
```

**Step 2: Build and test**

```bash
cd /Users/julienpequegnot/Code/xmon && go build -o xmon . && ./xmon digest --help
```

**Step 3: Commit**

```bash
cd /Users/julienpequegnot/Code/xmon && git add . && git commit -m "feat: add digest command"
```

---

## Task 12: Show Command

**Files:**
- Create: `cmd/show.go`

**Step 1: Create show.go**

```go
// cmd/show.go
package cmd

import (
	"fmt"
	"time"

	"github.com/charmbracelet/lipgloss"
	"github.com/jpequegn/xmon/internal/account"
	"github.com/jpequegn/xmon/internal/config"
	"github.com/jpequegn/xmon/internal/database"
	"github.com/jpequegn/xmon/internal/tweet"
	"github.com/spf13/cobra"
)

var showCmd = &cobra.Command{
	Use:   "show <username>",
	Short: "Show details for an account",
	Long:  `Displays detailed activity for a specific monitored account.`,
	Args:  cobra.ExactArgs(1),
	RunE:  runShow,
}

var (
	showDays int
)

func init() {
	rootCmd.AddCommand(showCmd)
	showCmd.Flags().IntVar(&showDays, "days", 7, "Number of days to show")
}

func runShow(cmd *cobra.Command, args []string) error {
	username := args[0]

	db, err := database.New(config.DBPath())
	if err != nil {
		return fmt.Errorf("failed to open database: %w", err)
	}
	defer db.Close()

	accountRepo := account.NewRepository(db)
	tweetRepo := tweet.NewRepository(db)

	acc, err := accountRepo.Get(username)
	if err != nil {
		return fmt.Errorf("account @%s not found", username)
	}

	since := time.Now().AddDate(0, 0, -showDays)

	tweets, _ := tweetRepo.GetForAccount(acc.ID, since)

	titleStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color("205"))
	sectionStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color("39"))
	dimStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("240"))

	fmt.Printf("\n%s\n", titleStyle.Render("@"+acc.Username))
	if acc.Name != "" {
		fmt.Println(acc.Name)
	}
	if acc.Bio != "" {
		fmt.Printf("%s\n", dimStyle.Render(acc.Bio))
	}
	fmt.Printf("%s\n\n", dimStyle.Render(fmt.Sprintf("%d followers", acc.Followers)))

	// Count by type
	originals, retweets, quotes := 0, 0, 0
	for _, t := range tweets {
		switch t.TweetType {
		case "original":
			originals++
		case "retweet":
			retweets++
		case "quote":
			quotes++
		}
	}

	fmt.Printf("%s (last %d days)\n", sectionStyle.Render("Activity"), showDays)
	fmt.Printf("  Originals: %d\n", originals)
	fmt.Printf("  Retweets:  %d\n", retweets)
	fmt.Printf("  Quotes:    %d\n", quotes)
	fmt.Println()

	// Recent tweets
	if len(tweets) > 0 {
		fmt.Printf("%s\n", sectionStyle.Render("Recent Tweets"))
		limit := 5
		if len(tweets) < limit {
			limit = len(tweets)
		}
		for i := 0; i < limit; i++ {
			t := tweets[i]
			content := t.Content
			if len(content) > 70 {
				content = content[:67] + "..."
			}
			fmt.Printf("  %s %s\n", dimStyle.Render(t.CreatedAt.Format("Jan 2")), content)
		}
	}

	return nil
}
```

**Step 2: Build and test**

```bash
cd /Users/julienpequegnot/Code/xmon && go build -o xmon . && ./xmon show --help
```

**Step 3: Commit**

```bash
cd /Users/julienpequegnot/Code/xmon && git add . && git commit -m "feat: add show command"
```

---

## Task 13: Update README and Final Tests

**Files:**
- Modify: `README.md`

**Step 1: Run all tests**

```bash
cd /Users/julienpequegnot/Code/xmon && go test ./... -v
```

**Step 2: Update README**

Update Development Status section:
```markdown
### Phase 1 (MVP) - Complete
- [x] Project setup
- [x] init command
- [x] add/remove commands
- [x] accounts command
- [x] X API client
- [x] fetch command
- [x] digest command
- [x] show command
```

**Step 3: Commit and push**

```bash
cd /Users/julienpequegnot/Code/xmon && git add . && git commit -m "docs: mark Phase 1 MVP as complete"
cd /Users/julienpequegnot/Code/xmon && git push
```

---

## Summary

**Phase 1 delivers:**
- Project structure with Cobra CLI
- Config and database packages
- X API client with rate limiting
- Account management (add/remove/list)
- Tweet fetching and storage
- Basic digest with activity summary
- Show command for individual accounts

**Commands available:**
```
xmon init              # Setup
xmon add <username>    # Add account
xmon remove <username> # Remove account
xmon accounts          # List accounts
xmon fetch             # Pull tweets
xmon digest            # View summary
xmon show <username>   # User details
```
